class ArgStream {
    var args: vec|tup;
    var index: i64 = 0;

    def $init(args: vec|tup) {
        self.args = args;
    }

    def next() -> str {
        self.index += 1;
        return self.args[self.index - 1];
    }

    def has_next() -> bool {
        return self.index < self.args:count();
    }
}


class Flag {
    var count: i64 = 0;

    def found() -> bool {
        return self.count > 0;
    }

    def count() -> i64 {
        return self.count;
    }
}


class Option {
    var parser: fn?(str) -> any;
    var default: any;
    var values: vec[any];

    def $init() {
        self.values = $vec();
    }

    def default(value: any) -> Option {
        self.default = value;
        return self;
    }

    def parser(func: fn(str) -> any) -> Option {
        self.parser = func;
        return self;
    }

    def try_append_value(value: str) -> bool {
        if self.parser {
            var parsed_value = try self.parser(value);
            if $is_err(parsed_value) {
                return false;
            } else {
                self.values:append(parsed_value);
                return true;
            }
        }
        self.values:append(value);
        return true;
    }

    def found() -> bool {
        return self.count > 0;
    }

    def count() -> i64 {
        return self.values:count();
    }

    def value() -> any {
        if self.values:count() > 0 {
            return self.values:last();
        } else {
            return self.default;
        }
    }

    def values() -> vec {
        return self.values;
    }
}


class ArgParser {
    var helptext: str?;
    var version: str?;
    var callback: fn?(str, ArgParser);
    var enable_help_command: bool = false;
    var exit_on_error: bool = true;

    var args: vec[str];
    var command_name: str?;
    var command_parser: ArgParser?;

    var options: map[str, Option];
    var flags: map[str, Flag];
    var commands: map[str, ArgParser];

    def $init() {
        self.options = $map();
        self.flags = $map();
        self.commands = $map();
        self.args = $vec();
    }

    # ---------------- #
    #  Setup methods.  #
    # ---------------- #

    def flag(name: str) -> Flag {
        var flag = Flag();
        for alias in name:split() {
            self.flags[alias] = flag;
        }
        return flag;
    }

    def option(name: str) -> Option {
        var option = Option();
        for alias in name:split() {
            self.options[alias] = option;
        }
        return option;
    }

    def command(name: str) -> ArgParser {
        self.enable_help_command = true;
        var cmd_parser = ArgParser();
        for alias in name:split() {
            self.commands[alias] = cmd_parser;
        }
        return cmd_parser;
    }

    # --------------------- #
    #  Inspection methods.  #
    # --------------------- #

    def count(name: str) -> i64 {
        if name in self.flags {
            return self.flags[name]:count();
        } else if name in self.options {
            return self.options[name]:count();
        } else {
            $panic("count(): '{}' is not a registered flag or option name", name);
        }
    }

    def found(name: str) -> bool {
        return self:count(name) > 0;
    }

    def value(name: str) -> any {
        if name in self.options {
            return self.options[name]:value();
        } else {
            $panic("value(): '{}' is not a registered option name", name);
        }
    }

    def values(name: str) -> any {
        if name in self.options {
            return self.options[name]:values();
        } else {
            $panic("values(): '{}' is not a registered option name", name);
        }
    }

    # -------------------- #
    #  Parsing machinery.  #
    # -------------------- #

    def parse() -> err? {
        if $args:count() > 1 {
            var args = $args:slice(1);
            return self:parse_args(args);
        }
    }

    def parse_args(args: vec[str]|tup[str]) -> err? {
        var stream = ArgStream(args);
        var result = try self:parse_stream(stream);
        if $is_err(result) {
            if self.exit_on_error {
                self:exit_with_error(result[0]);
            } else {
                return $err(result[0]);
            }
        }
    }

    def parse_stream(stream: ArgStream) {
        var is_first_arg = true;

        while (stream:has_next()) {
            var arg = stream:next();

            if arg == "--" {
                while (stream:has_next()) {
                    self.args:append(stream:next());
                }
            }

            else if arg:starts_with("--") {
                if arg:contains("=") {
                    self:handle_equals_option(arg:slice(2));
                } else {
                    self:handle_long_option(arg:slice(2), stream);
                }
            }

            else if arg:starts_with("-") {
                if arg == "-" || (arg:byte(1) >= '0' && arg:byte(1) <= '9') {
                    self.args:append(arg);
                } else if arg:contains("=") {
                    self:handle_equals_option(arg:slice(1));
                } else {
                    self:handle_short_option(arg:slice(1), stream);
                }
            }

            else if is_first_arg && self.commands:contains(arg) {
                self.command_name = arg;
                self.command_parser = self.commands[arg];
                self.command_parser:parse_stream(stream);
                if self.command_parser.callback {
                    self.command_parser.callback(arg, self.command_parser);
                }
            }

            else if is_first_arg && self.enable_help_command && arg == "help" {
                if stream:has_next() {
                    var name = stream:next();
                    if self.commands:contains(name) {
                        self.commands[name]:exit_with_help();
                    } else {
                        $panic("'{}' is not a recognised command", name);
                    }
                } else {
                    $panic("expected an argument for the help command");
                }
            }

            else {
                self.args:append(arg);
            }

            is_first_arg = false;
        }
    }

    # Parse an option of the form --name=value or -n=value.
    def handle_equals_option(arg: str) {
        var index = arg:index_of("=");
        var name = arg:slice(0, index);
        var value = arg:slice(index + 1);

        if self.options:contains(name) {
            if !self.options[name]:try_append_value(value) {
                $panic("invalid option value '{}'", value);
            }
        } else {
            $panic("'{}' is not a recognised option name", name);
        }
    }

    # Parse a long-form option, i.e. an option beginning with a double dash.
    def handle_long_option(arg: str, stream: ArgStream) {
        if self.flags:contains(arg) {
            self.flags[arg].count += 1;
        } else if self.options:contains(arg) {
            if stream:has_next() {
                var value = stream:next();
                if !self.options[arg]:try_append_value(value) {
                    $panic("invalid option value '{}'", value);
                }
            } else {
                $panic("option --{} requires an argument", arg);
            }
        } else if arg == "help" && self.helptext {
            self:exit_with_help();
        } else if arg == "version" && self.version {
            self:exit_with_version();
        } else {
            $panic("--{} is not a recognised flag or option name", arg);
        }
    }

    # Parse a short-form option, i.e. an option beginning with a single dash.
    def handle_short_option(arg: str, stream: ArgStream) {
        for char in arg {
            if self.flags:contains(char) {
                self.flags[char].count += 1;
            } else if self.options:contains(char) {
                if stream:has_next() {
                    var value = stream:next();
                    if !self.options[char]:try_append_value(value) {
                        $panic("invalid option value '{}'", value);
                    }
                } else if arg:byte_count() > 1 {
                    $panic("option '{}' in -{} requires an argument", char, arg);
                } else {
                    $panic("option -{} requires an argument", char);
                }
            } else if char == "h" && self.helptext {
                self:exit_with_help();
            } else if char == "v" && self.version {
                self:exit_with_version();
            } else if arg:byte_count() > 1 {
                $panic("'{}' in -{} is not a recognised flag or option name", char, arg);
            } else {
                $panic("-{} is not a recognised flag or option name", arg);
            }
        }
    }

    # ------------ #
    #  Utilities.  #
    # ------------ #

    def exit_with_help() {
        if self.helptext {
            $println(self.helptext:strip());
        }
        $exit(0);
    }

    def exit_with_version() {
        if self.version {
            $println(self.version:strip());
        }
        $exit(0);
    }

    def exit_with_error(message: str) {
        $eprintln("Error: {}.", message);
        $exit(1);
    }

    def print() {
        $println("Flags:");
        if self.flags:count() > 0 {
            for (name, flag) in self.flags {
                $println("  {}: {}", name, flag:count());
            }
        } else {
            $println(" [none]");
        }

        $println("\nOptions:");
        if self.options:count() > 0 {
            for (name, option) in self.options {
                $println("  {}: ({}) {}", name, $debug(option.default), option.values);
            }
        } else {
            $println(" [none]");
        }

        $println("\nArguments:");
        if self.args:count() > 0 {
            for arg in self.args {
                $println("  {}", arg);
            }
        } else {
            $println("  [none]");
        }

        $println("\nCommand:");
        if self.command_name {
            $println("  {}", self.command_name);
        } else {
            $println("  [none]");
        }
    }
}
