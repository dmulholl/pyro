import $std::pyro;


var url_reserved_chars = " !#$%&'()*+,/:;=?@[]":bytes():to_set();


pub def url_encode(input: str) -> str {
    var buf = $buf();

    for byte in input:bytes() {
        if byte in url_reserved_chars {
            buf:write("%{02X}", byte);
        } else {
            buf:write_byte(byte);
        }
    }

    return buf:to_str();
}


pub def url_decode(input: str) -> str|err {
    var index = 0;
    var count = input:count();
    var buf = $buf();

    while index < count {
        var char = input[index];
        if char == "+" {
            buf:write(" ");
            index += 1;
        } else if char == "%" {
            if count - index >= 3 {
                var value = try $i64("0x" + input:slice(index + 1, 2));
                if $is_err(value) {
                    return $err();
                }
                buf:write_byte(value);
                index += 3;
            } else {
                return $err();
            }
        } else {
            buf:write(char);
            index += 1;
        }
    }

    return buf:to_str();
}


pub class Request {
    pub var method: str;
    pub var content_type: str;

    var body: str?;
    var data: map[str, vec[str]];

    def $init() {
        self.method = $env("REQUEST_METHOD");
        self.content_type = $env("CONTENT_TYPE");
        self.data = $map();

        if self.method in $tup("POST", "PUT") {
            if self.content_type == "application/x-www-form-urlencoded" {
                self:unpack_url_encoded_string(self:body());
            } else if self.content_type == "multipart/form-data" {
                # Not implemented.
            }
        }

        var query_string = $env("QUERY_STRING");
        if $is_str(query_string) {
            self:unpack_url_encoded_string(query_string);
        }
    }

    def $str() {
        return $str(self.data);
    }

    pub def body() -> str {
        if $is_str(self.body) {
            return self.body;
        }
        self.body = pyro::stdin():read_string();
        return self.body;
    }

    pub def found(key: str) -> bool {
        return key in self.data;
    }

    pub def value(key: str) -> str|err {
        var values = self.data[key];
        if $is_err(values) {
            return $err();
        }
        return try values:last();
    }

    pub def values(key: str) -> vec[str]|err {
        return self.data[key];
    }

    def unpack_url_encoded_string(input: str) {
        for element in input:split("&") {
            if element:contains("=") {
                var parts = element:split("=");
                var key = url_decode(parts[0]);
                var value = url_decode(parts[1]);

                var values = self.data[key];
                if $is_err(values) {
                    self.data[key] = [value];
                } else {
                    values:append(value);
                }
            }
        }
    }
}


pub class Response {
    var headers: vec[str];
    var body: buf;

    def $init() {
        self.headers = $vec();
        self.body = $buf();
    }

    pub def add_header(header: str) -> Response {
        self.headers:append(header);
        return self;
    }

    pub def make_301_redirect(url: str) -> Response {
        self:add_header("Status: 301 Moved Permanently");
        self:add_header("Location: " + url);
        return self;
    }

    pub def make_302_redirect(url: str) -> Response {
        self:add_header("Status: 302 Found");
        self:add_header("Location: " + url);
        return self;
    }

    pub def make_303_redirect(url: str) -> Response {
        self:add_header("Status: 303 See Other");
        self:add_header("Location: " + url);
        return self;
    }

    pub def make_307_redirect(url: str) -> Response {
        self:add_header("Status: 307 Temporary Redirect");
        self:add_header("Location: " + url);
        return self;
    }

    pub def write(*args) -> Response {
        self.body:write(*args);
        return self;
    }

    pub def send() {
        var response = $buf();

        for header in self.headers {
            var line = header:strip():replace("\r", "\\r"):replace("\n", "\\n");
            response:write("{}\r\n", line);
        }

        response:write("\r\n");
        response:write($str(self.body):strip());
        $println(response);
    }
}
