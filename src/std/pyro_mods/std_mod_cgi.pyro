import $std::pyro;


var url_reserved_chars = " !#$%&'()*+,/:;=?@[]":bytes():to_set();


def url_encode(input: str) -> str {
    var buf = $buf();

    for byte in input:bytes() {
        if byte in url_reserved_chars {
            buf:write("%{02X}", byte);
        } else {
            buf:write_byte(byte);
        }
    }

    return buf:to_str();
}


def url_decode(input: str) -> str|err {
    var index = 0;
    var count = input:count();
    var buf = $buf();

    while index < count {
        var char = input[index];
        if char == "+" {
            buf:write(" ");
            index += 1;
        } else if char == "%" {
            if count - index >= 3 {
                var value = try $i64("0x" + input:slice(index + 1, 2));
                if $is_err(value) {
                    return $err();
                }
                buf:write_byte(value);
                index += 3;
            } else {
                return $err();
            }
        } else {
            buf:write(char);
            index += 1;
        }
    }

    return buf:to_str();
}


class Request {
    # Public.
    var method: str;
    var content_type: str;

    # Private.
    var _body: str?;
    var _data: map[str, vec[str]];

    def $init() {
        self.method = $env("REQUEST_METHOD");
        self.content_type = $env("CONTENT_TYPE");
        self._data = $map();

        if self.method in $tup("POST", "PUT") {
            if self.content_type == "application/x-www-form-urlencoded" {
                self:_unpack_url_encoded_string(self:body());
            } else if self.content_type == "multipart/form-data" {
                # Not implemented.
            }
        }

        var query_string = $env("QUERY_STRING");
        if $is_str(query_string) {
            self:_unpack_url_encoded_string(query_string);
        }
    }

    def body() -> str {
        if $is_str(self._body) {
            return self._body;
        }
        self._body = pyro::stdin():read_string();
        return self._body;
    }

    def found(key: str) -> bool {
        return key in self._data;
    }

    def value(key: str) -> str|err {
        var values = self._data[key];
        if $is_err(values) {
            return $err();
        }
        return try values:last();
    }

    def values(key: str) -> vec[str]|err {
        return self._data[key];
    }

    def _unpack_url_encoded_string(input: str) {
        for element in input:split("&") {
            if element:contains("=") {
                var parts = element:split("=");
                var key = url_decode(parts[0]);
                var value = url_decode(parts[1]);

                var values = self._data[key];
                if $is_err(values) {
                    self._data[key] = [value];
                } else {
                    values:append(value);
                }
            }
        }
    }
}


class Response {
    var _headers: vec[str];
    var _body: buf;

    def $init() {
        self._headers = $vec();
        self._body = $buf();
    }

    def add_header(header: str) -> Response {
        self._headers:append(header);
        return self;
    }

    def make_301_redirect(url: str) -> Response {
        self:add_header("Status: 301 Moved Permanently");
        self:add_header("Location: " + url);
        return self;
    }

    def make_302_redirect(url: str) -> Response {
        self:add_header("Status: 302 Found");
        self:add_header("Location: " + url);
        return self;
    }

    def make_303_redirect(url: str) -> Response {
        self:add_header("Status: 303 See Other");
        self:add_header("Location: " + url);
        return self;
    }

    def make_307_redirect(url: str) -> Response {
        self:add_header("Status: 307 Temporary Redirect");
        self:add_header("Location: " + url);
        return self;
    }

    def write(*args) -> Response {
        self._body:write(*args);
        return self;
    }

    def send() {
        var response = self:_make_response();
        $println(response);
    }

    def _make_response() -> buf {
        var response = $buf();

        for header in self._headers {
            var header_string = header:strip():replace("\r", "\\r"):replace("\n", "\\n");
            response:write("{}\r\n", header_string);
        }

        response:write("\r\n");
        response:write($str(self._body):strip());

        return response;
    }
}
