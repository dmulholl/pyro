# ------------ #
#  Statements  #
# ------------ #

program = statement* EOF ;

statement = block
          | declaration
          | echo_statement
          | assert_statement
          | if_statement
          | while_statement
          | for_statement
          | break_statement
          | continue_statement
          | return_statement
          | expression_statement ;

block = "{" statement* "}" ;

declaration = variable_declaration | function_declaration | class_declaration ;

variable_declaration = "var" IDENTIFIER ( "=" expression )? ";" ;

function_declaration = "def" IDENTIFIER "(" parameters? ")" block ;

class_declaration = "class" IDENTIFIER ( "<" IDENTIFIER )?
                    "{"
                    ( variable_declaration | function_declaration )*
                    "}" ;

parameters = IDENTIFIER ( "," IDENTIFIER )* ;

expression_statement = expression ";" ;

if_statement = "if" expression block ( "else" ( if_statement | block ) )? ;

echo_statement = "echo" ( expression ( "," expression )* )? ";" ;

while_statement = "while" expression block ;

for_statement = "for"
                ( variable_declaration | expression_statement | ";" )
                expression? ";"
                expression?
                block ;

break_statement = "break" ";" ;

continue_statement = "continue" ";" ;

return_statement = "return" expression? ";" ;

# ------------- #
#  Expressions  #
# ------------- #

# Each rule matches expressions at its precedence level or higher.

expression = assignment_expression ;

assignment_expression = ( call_expression "." )? IDENTIFIER ( "=" | "+=" | "-=" ) assignment_expression | conditional_expression ;

conditional_expression = logical_expression ( "?" logical_expression "|" logical_expression )? ;

logical_expression = equivalence_expression ( ( "and" | "or" ) equivalence_expression )* ;

equivalence_expression = comparative_expression ( ( "!=" | "==" ) comparative_expression )* ;

comparative_expression = additive_expression ( ( ">" | ">=" | "<" | "<=" ) additive_expression )* ;

additive_expression = multiplicative_expression ( ( "-" | "+" ) multiplicative_expression )* ;

multiplicative_expression = unary_expression ( ( "/" | "*" ) unary_expression )* ;

unary_expression = ( "!" | "-" | "try" ) unary_expression | power_expression ;

power_expression = call_expression ( "^" unary_expression ) ;

call_expression = primary_expression ( "(" arguments? ")" | ( "." | ":" ) IDENTIFIER )* ;

primary_expression = "true" | "false" | "null" | "self"
                   | NUMBER | STRING | IDENTIFIER
                   | "(" expression ")"
                   | "super" ":" IDENTIFIER
                   | function_expression;

function_expression = "def" "(" parameters? ")" block ;

arguments = expression ( "," expression )* ;

# ------- #
#  Types  #
# ------- #

atomic_type = identifier ( "::" identifier )* ( "?" )? ;

container_type = atomic_type "[" type ( "," type )* "]" ;

callable_type = atomic_type ( "(" ( type ( "," type )* )? ")" )? ( "->" type )? ;

single_type = atomic_type | container_type | callable_type ;

bracketed_type = single_type | "(" single_type ")" ;

type = bracketed_type ( "|" bracketed_type )* ;
