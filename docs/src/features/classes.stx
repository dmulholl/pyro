---
title: Classes
meta_title: Pyro &mdash; Classes
---

::: insert toc


### Class Definitions

Class definitions look like this:

::: code pyro
    class Person {
        var name;
        var role = "programmer";

        def $init(name) {
            self.name = name;
        }

        def info() {
            $println("{} is a {}.", self.name, self.role);
        }
    }

Create an instance of a class by calling its name:

::: code pyro
    var dave = Person("Dave");

Arguments are passed on to the optional `$init()` method.



### Fields and Methods

Get or set an instance's fields using the field access operator `.`:

::: code pyro
    dave.role = "pyro programmer";

Call a method on an instance using the method access operator `:`:

::: code pyro
    dave:info();

Methods are bound to their instances and you can pass them around just like any other function:

::: code pyro
    var method = dave:info;
    method(); # "Dave is a pyro programmer."



### Field Initializers

Field initializers are evaluated once when the class statement itself is executed ---
each instance gets a copy of these values.

Don't do this:

::: code pyro
    class Person {
        var hobbies = $vec();
    }

All instances of `Person` will share a single `hobbies` vector!

Use field initializers for immutable values like strings, booleans, or numbers.
Initialize mutable objects from the `$init()` method instead:

::: code pyro
    class Person {
        var hobbies;

        def $init() {
            self.hobbies = $vec();
        }
    }

This way, each `Person` instance gets its own individual `hobbies` vector.



### Inheritance

A class can inherit from a superclass.

::: code pyro
    class Shape {
        var color;

        def $init(color) {
            self.color = color;
        }

        def info() {
            echo "color: " + self.color;
        }
    }

    class Circle < Shape {
        var radius;

        def $init(color, radius) {
            super:$init(color);
            self.radius = radius;
        }

        def info() {
            super:info();
            echo "radius: " + $str(self.radius);
        }
    }

Subclass methods override superclass methods as you'd expect.
A subclass can use the `super` keyword to access an overridden superclass method.



### Indexing

You can add indexing support to a class by implementing `$get_index(key)` and/or `$set_index(key, value)` methods.

Accessing an index:

::: code pyro
    var foo = object[key];

is equivalent to calling the object's `$get_index(key)` method.

Assigning to an index:

::: code pyro
    object[key] = value;

is equivalent to calling the object's `$set_index(key, value)` method.



### Special Methods

You can implement the `$special` methods listed below to add support for various language features to your types:


[[ `:$call()` ]]

    Implementing this method makes instances of the type callable.


[[ `:$debug() -> str` ]]

    This method should return a string representation of the instance suitable for debugging.


[[ `:$fmt(format_specifier: str) -> str` ]]

    This method should return a string representation of the instance formatted according to the `format_specifier` string.


[[ `:$get_index(key: any) -> any` ]]

    Implementing this method adds support for index-style read access to instances.


[[ `:$hash() -> i64` ]]

    Implementing this method allows you to set a custom hash value for instances.
    (By default an instance's hash value is simply its memory address.)

    Hash values are used for looking up entries in the builtin `map` and `set` types.


[[ `:$init()` ]]

    Constructor method for initializing new instances.


[[ `:$iter() -> iterator` ]]

    Implementing this method makes the type iterable.
    The method should return an iterator, i.e. an object with a `:$next()` method.


[[ `:$next() -> any` ]]

    Implementing this method makes the type an iterator.
    The method should return either the next item from a sequence or an `err` if the sequence has been exhausted.


[[ `:$op_binary_equals_equals(other: any) -> bool` ]]

    Implementing this method overloads the `==` operator for expressions of the form `receiver == other`.
    (The `!=` operator automatically returns the logical inverse of `==` and cannot be separately overloaded.)

    If you overload this operator and you want to use your overloaded type as a key in hash maps or as a member in sets you should also overload the `:$hash()` method to ensure that instances that compare as equal also have the same hash value.


[[ `:$op_binary_greater(other: any) -> bool` ]]

    Implementing this method overloads the `>` operator for expressions of the form `receiver > other`.


[[ `:$op_binary_greater_equals(other: any) -> bool` ]]

    Implementing this method overloads the `>=` operator for expressions of the form `receiver >= other`.


[[ `:$op_binary_less(other: any) -> bool` ]]

    Implementing this method overloads the `<` operator for expressions of the form `receiver < other`.


[[ `:$op_binary_less_equals(other: any) -> bool` ]]

    Implementing this method overloads the `<=` operator for expressions of the form `receiver <= other`.


[[ `:$set_index(key: any, value: any)` ]]

    Implementing this method adds support for index-style write access to instances.


[[ `:$str() -> str` ]]

    This method should return the instance's default string representation.
