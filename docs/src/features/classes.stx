---
title: Classes
meta_title: Pyro &mdash; Classes
---

[1]: @root/features/iterators//
[2]: @root/builtins/maps//
[3]: @root/builtins/sets//


::: insert toc


### Class Definitions

Class definitions look like this:

::: code pyro
    class Person {
        var name;
        var role = "programmer";

        def $init(name) {
            self.name = name;
        }

        def info() {
            $println("{} is a {}.", self.name, self.role);
        }
    }

Create an instance of a class by calling its name:

::: code pyro
    var dave = Person("Dave");

Arguments are passed on to the optional `$init()` method.



### Fields and Methods

Get or set an instance's fields using the field access operator `.`:

::: code pyro
    dave.role = "pyro programmer";

Call a method on an instance using the method access operator `:`:

::: code pyro
    dave:info();

Methods are bound to their instances and you can pass them around just like any other function:

::: code pyro
    var method = dave:info;
    method(); # "Dave is a pyro programmer."



### Field Initializers

Field initializers are evaluated once when the class statement itself is executed ---
each instance gets a copy of these values.

Don't do this:

::: code pyro
    class Person {
        var hobbies = $vec();
    }

All instances of `Person` will share a single `hobbies` vector!

Use field initializers for immutable values like strings, booleans, or numbers.
Initialize mutable objects from the `$init()` method instead:

::: code pyro
    class Person {
        var hobbies;

        def $init() {
            self.hobbies = $vec();
        }
    }

This way, each `Person` instance gets its own individual `hobbies` vector.



### Inheritance

A class can inherit from a superclass.

::: code pyro
    class Shape {
        var color;

        def $init(color) {
            self.color = color;
        }

        def info() {
            $println("color: {}", self.color);
        }
    }

    class Circle < Shape {
        var radius;

        def $init(color, radius) {
            super:$init(color);
            self.radius = radius;
        }

        def info() {
            super:info();
            $println("radius: {}", self.radius);
        }
    }

Subclass methods override superclass methods as you'd expect.
A subclass can use the `super` keyword to access an overridden superclass method.



### Indexing

You can add indexing support to a class by implementing `$get_index(key)` and/or `$set_index(key, value)` methods.

Accessing an index:

::: code pyro
    var foo = object[key];

is equivalent to calling the object's `:$get_index(key)` method.

Assigning to an index:

::: code pyro
    object[key] = value;

is equivalent to calling the object's `:$set_index(key, value)` method.



### Special Methods

You can implement the `$special` methods listed below to add support for various language features to your types:


[[ `:$call(arg1: any, arg2: any, ...) -> any` ]]

    Implementing this method makes instances of the type callable.
    (When an instance is called, the call will be handled by this method.)


[[ `:$contains(item: any) -> bool` ]]

    Implementing this method adds support for the `in` operator.
    The method should return `true` if the receiver contains `item`, otherwise `false`.

[[ `:$debug() -> str` ]]

    This method should return a string representation of the instance suitable for debugging.


[[ `:$fmt(format_specifier: str) -> str` ]]

    This method should return a string representation of the instance formatted according to the `format_specifier` string.


[[ `:$get_index(key: any) -> any` ]]

    Implementing this method adds support for index-style read access to instances, e.g.

    ::: code pyro
        var value = instance[key];


[[ `:$hash() -> i64` ]]

    Implementing this method allows you to set a custom hash value for instances.
    (By default an instance's hash value is simply its memory address.)

    Hash values are used for looking up entries in the builtin `map` and `set` types.


[[ `:$init(arg1: any, arg2: any, ...)` ]]

    Constructor method for initializing new instances.


[[ `:$iter() -> iterator` ]]

    Implementing this method makes the type *iterable*.

    The method should return an *iterator* --- i.e. an object with a `:$next()` method that returns either
    the next item from a sequence or an `err` if the sequence has been exhausted.

    See the documentation on [iterators][1] for details.


[[ `:$json() -> str` ]]

    If implemented, this method should return a string containing the object serialized to JSON.

    This method is used by the `$std::json` library to serialize objects to JSON.


[[ `:$next() -> any` ]]

    Implementing this method makes the type an *iterator*.

    The method should return either the next item from a sequence or an `err` if the sequence has been exhausted.

    See the documentation on [iterators][1] for details.


[[ `:$op_binary_amp(other: any) -> any` ]]

    Implementing this method overloads the binary `&` operator for expressions of the form `receiver & other`.


[[ `:$op_binary_bar(other: any) -> any` ]]

    Implementing this method overloads the binary `|` operator for expressions of the form `receiver | other`.


[[ `:$op_binary_caret(other: any) -> any` ]]

    Implementing this method overloads the binary `^` operator for expressions of the form `receiver ^ other`.


[[ `:$op_binary_equals_equals(other: any) -> bool` ]]

    Implementing this method overloads the binary `==` operator for expressions of the form `receiver == other`.
    (The `!=` operator automatically returns the logical inverse of `==` and cannot be separately overloaded.)

    If you overload this operator and you want to use your overloaded type as a key in [hash maps][2] or as a member in [sets][3] you should also overload the `:$hash()` method to ensure that instances that compare as equal also have the same hash value.


[[ `:$op_binary_greater(other: any) -> bool` ]]

    Implementing this method overloads the binary `>` operator for expressions of the form `receiver > other`.


[[ `:$op_binary_greater_equals(other: any) -> bool` ]]

    Implementing this method overloads the binary `>=` operator for expressions of the form `receiver >= other`.


[[ `:$op_binary_less(other: any) -> bool` ]]

    Implementing this method overloads the binary `<` operator for expressions of the form `receiver < other`.


[[ `:$op_binary_less_equals(other: any) -> bool` ]]

    Implementing this method overloads the binary `<=` operator for expressions of the form `receiver <= other`.


[[ `:$op_binary_minus(other: any) -> any` ]]

    Implementing this method overloads the binary `-` operator for expressions of the form `receiver - other`.


[[ `:$op_binary_percent(other: any) -> any` ]]

    Implementing this method overloads the binary `%` operator for expressions of the form `receiver % other`.


[[ `:$op_binary_plus(other: any) -> any` ]]

    Implementing this method overloads the binary `+` operator for expressions of the form `receiver + other`.


[[ `:$op_binary_slash(other: any) -> any` ]]

    Implementing this method overloads the binary `/` operator for expressions of the form `receiver / other`.


[[ `:$op_binary_star(other: any) -> any` ]]

    Implementing this method overloads the binary `*` operator for expressions of the form `receiver * other`.


[[ `:$op_binary_star_star(other: any) -> any` ]]

    Implementing this method overloads the binary `**` operator for expressions of the form `receiver ** other`.


[[ `:$op_unary_minus() -> any` ]]

    Implementing this method overloads the unary `-` operator for expressions of the form `-receiver`.


[[ `:$op_unary_plus() -> any` ]]

    Implementing this method overloads the unary `+` operator for expressions of the form `+receiver`.


[[ `:$set_index(key: any, value: any)` ]]

    Implementing this method adds support for index-style write access to instances, e.g.

    ::: code pyro
        instance[key] = value;


[[ `:$str() -> str` ]]

    This method should return the instance's default string representation.
