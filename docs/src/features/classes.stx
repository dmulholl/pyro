---
title: Classes
meta_title: Pyro &mdash; Classes
---

[1]: @root/features/iterators//
[2]: @root/builtins/maps//
[3]: @root/builtins/sets//


::: insert toc


### Class Definitions

Class definitions look like this:

::: code pyro
    class Person {
        pub var name;
        pub var role = "programmer";

        def $init(name) {
            self.name = name;
        }

        pub def info() {
            $println("{} is a {}.", self.name, self.role);
        }
    }

Create an instance of a class by calling its name:

::: code pyro
    var dave = Person("Dave");

Arguments are passed on to the optional `$init()` method.



### Fields and Methods

Get or set an instance's fields using the field access operator `.`, e.g.

::: code pyro
    dave.role = "pyro programmer";

Call a method on an instance using the method access operator `:`, e.g.

::: code pyro
    dave:info();

Methods are bound to their instances and you can pass them around just like any other function:

::: code pyro
    var method = dave:info;
    method(); # "Dave is a pyro programmer."



### Public/Private Members

Fields and methods are private by default --- use the `pub` keyword to make them public:

::: code pyro
    class Foo {
        pub var public_field;
        var private_field;

        pub def public_method() {
            return "public";
        }

        def private_method() {
            return "private";
        }
    }

* Public members can be accessed from inside or outside the class.
* Private members can only be accessed from inside the class using `self` or `super`.



### The Self Keyword

Use the `self` keyword inside a class to access the instance's fields and methods:

::: code pyro
    class Foo {
        var field;

        def private_method() {
            return self.field;
        }

        pub def public_method() {
            return self:private_method();
        }
    }



### Static Members

Static fields and methods are defined on the class object itself:

::: code pyro
    class Object {
        static var count = 0;

        static def increment() {
            Object.count += 1;
        }
    }

    Object:increment();
    assert Object.count == 1;

Static members can't be accessed from instances of the class:

::: code pyro
    var obj = Object();
    assert $is_err(try obj.count);
    assert $is_err(try obj:increment());

Note that you can't use `self` or `super` inside static methods.



### Field Initializers

Uninitialized fields have the default value `null`.

You can specify default values for fields, e.g.

::: code pyro
    class Foo {
        pub var bar = 123;
        pub var baz;
    }

    var foo = Foo();
    assert foo.bar == 123;
    assert foo.baz == null;

A default field value must be a simple literal --- one of `i64`, `f64`, `char`, `str`, `bool`, or `null`.

(This restriction only applies to instance fields. Static fields can be initialized to any value.)



### Inheritance

A class can inherit from a superclass.

::: code pyro
    class Shape {
        var color;

        def $init(color) {
            self.color = color;
        }

        pub def info() {
            $println("color: {}", self.color);
        }
    }

    class Circle < Shape {
        var radius;

        def $init(color, radius) {
            super:$init(color);
            self.radius = radius;
        }

        pub def info() {
            super:info();
            $println("radius: {}", self.radius);
        }
    }

Subclass methods override superclass methods as you'd expect.
A subclass can use the `super` keyword to access an overridden superclass method.



### Indexing

You can add indexing support to a class by implementing `$get_index(key)` and/or `$set_index(key, value)` methods.

Accessing an index:

::: code pyro
    var foo = object[key];

is equivalent to calling the object's `:$get_index(key)` method.

Assigning to an index:

::: code pyro
    object[key] = value;

is equivalent to calling the object's `:$set_index(key, value)` method.



### Dollar Methods

You can implement the `$`-prefixed methods listed below to overload operators or add support for various language features to your types:


[[ `:$call(arg1: any, arg2: any, ...) -> any` ]]

    Implementing this method makes instances of the type callable.
    (When an instance is called, the call will be handled by this method.)


[[ `:$contains(item: any) -> bool` ]]

    Implementing this method adds support for the `in` operator.
    The method should return `true` if the receiver contains `item`, otherwise `false`.

[[ `:$debug() -> str` ]]

    This method should return a string representation of the instance suitable for debugging.


[[ `:$end_with()` ]]

    This method will be called when a `with` block exits.
    The method will be called even if the code in the `with` block panics or returns early.
    Can be used to run clean-up code.


[[ `:$fmt(format_specifier: str) -> str` ]]

    This method should return a string representation of the instance formatted according to the `format_specifier` string.


[[ `:$get_index(key: any) -> any` ]]

    Implementing this method adds support for index-style read access to instances, e.g.

    ::: code pyro
        var value = instance[key];


[[ `:$hash() -> i64` ]]

    Implementing this method allows you to set a custom hash value for instances.
    (By default an instance's hash value is simply its memory address.)

    Hash values are used for looking up entries in the builtin `map` and `set` types.


[[ `:$init(arg1: any, arg2: any, ...)` ]]

    Constructor method for initializing new instances.


[[ `:$iter() -> iterator` ]]

    Implementing this method makes the type *iterable*.

    The method should return an *iterator* --- i.e. an object with a `:$next()` method that returns either
    the next item from a sequence or an `err` if the sequence has been exhausted.

    See the documentation on [iterators][1] for details.


[[ `:$json() -> str` ]]

    If implemented, this method should return a string containing the object serialized to JSON.

    This method is used by the `$std::json` library to serialize objects to JSON.


[[ `:$next() -> any` ]]

    Implementing this method makes the type an *iterator*.

    The method should return either the next item from a sequence or an `err` if the sequence has been exhausted.

    See the documentation on [iterators][1] for details.


[[ `:$op_binary_amp(other: any) -> any` ]]

    Implementing this method overloads the binary `&` operator for expressions of the form `receiver & other`.


[[ `:$op_binary_bar(other: any) -> any` ]]

    Implementing this method overloads the binary `|` operator for expressions of the form `receiver | other`.


[[ `:$op_binary_caret(other: any) -> any` ]]

    Implementing this method overloads the binary `^` operator for expressions of the form `receiver ^ other`.


[[ `:$op_binary_equals_equals(other: any) -> bool` ]]

    Implementing this method overloads the binary `==` operator for expressions of the form `receiver == other`.
    (The `!=` operator automatically returns the logical inverse of `==` and cannot be separately overloaded.)

    If you overload this operator and you want to use your overloaded type as a key in [hash maps][2] or as a member in [sets][3] you should also overload the `:$hash()` method to ensure that instances that compare as equal also have the same hash value.


[[ `:$op_binary_greater(other: any) -> bool` ]]

    Implementing this method overloads the binary `>` operator for expressions of the form `receiver > other`.


[[ `:$op_binary_greater_equals(other: any) -> bool` ]]

    Implementing this method overloads the binary `>=` operator for expressions of the form `receiver >= other`.


[[ `:$op_binary_less(other: any) -> bool` ]]

    Implementing this method overloads the binary `<` operator for expressions of the form `receiver < other`.


[[ `:$op_binary_less_equals(other: any) -> bool` ]]

    Implementing this method overloads the binary `<=` operator for expressions of the form `receiver <= other`.


[[ `:$op_binary_minus(other: any) -> any` ]]

    Implementing this method overloads the binary `-` operator for expressions of the form `receiver - other`.


[[ `:$op_binary_percent(other: any) -> any` ]]

    Implementing this method overloads the binary `%` operator for expressions of the form `receiver % other`.


[[ `:$op_binary_plus(other: any) -> any` ]]

    Implementing this method overloads the binary `+` operator for expressions of the form `receiver + other`.


[[ `:$op_binary_slash(other: any) -> any` ]]

    Implementing this method overloads the binary `/` operator for expressions of the form `receiver / other`.


[[ `:$op_binary_slash_slash(other: any) -> any` ]]

    Implementing this method overloads the binary `//` operator for expressions of the form `receiver // other`.


[[ `:$op_binary_star(other: any) -> any` ]]

    Implementing this method overloads the binary `*` operator for expressions of the form `receiver * other`.


[[ `:$op_binary_star_star(other: any) -> any` ]]

    Implementing this method overloads the binary `**` operator for expressions of the form `receiver ** other`.


[[ `:$op_unary_minus() -> any` ]]

    Implementing this method overloads the unary `-` operator for expressions of the form `-receiver`.


[[ `:$op_unary_plus() -> any` ]]

    Implementing this method overloads the unary `+` operator for expressions of the form `+receiver`.


[[ `:$set_index(key: any, value: any)` ]]

    Implementing this method adds support for index-style write access to instances, e.g.

    ::: code pyro
        instance[key] = value;


[[ `:$str() -> str` ]]

    This method should return the instance's default string representation.
