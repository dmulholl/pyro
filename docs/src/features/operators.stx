---
title: Operators
meta_title: Pyro &mdash; Operators
---

::: insert toc


### Operator Precedence

Operator precedence in the table below goes from high at the top to low at the bottom. Operators at the same level have the same precedence.

::: table

    Level            |   Operators                                       |   Associativity
    -------------------------------------------------------------------------------

    Call             |   `()` `[]` `.` `:` `::`                          |   Left
    Power            |   `**`                                            |   Right
    Unary            |   `!` `+` `-` `~` `try`                           |   Right
    Bitwise          |   `&` <code>&#124;</code> `^` `>>` `<<`           |   Left
    Multiplication   |   `*` `/` `//` `%`                                |   Left
    Addition         |   `+` `-`                                         |   Left
    Comparison       |   `>` `>=` `<` `<=` `in`                          |   Left
    Equality         |   `==` `!=`                                       |   Left
    Logical          |   `&&` <code>&#124;&#124;</code> `??` `!!` `else` |   Left
    Conditional      |   <code>? :&#124;</code>                          |   None
    Assignment       |   `=` `+=` `-=`                                   |   Right


Note that conditional expressions using the ternary operator `? :|` can't be nested. (Checkmate, Satan.)



### Mathematical Operators

::: table

    +       | Addition (binary) or a no op (unary). Addition returns an integer if both operands are integers or a float if either or both are floats.
    -       | Subtraction (binary) or negation (unary). Subtraction returns an integer if both operands are integers or a float if either or both are floats.
    *       | Multiplication. Returns an integer if both operands are integers or a float if either or both are floats.
    /       | Floating-point division. Both operands will be converted to floats and the result will be a float.
    //      | Truncating division. Returns an integer if both operands are integers or a float if either or both are floats.
    %       | Modulo/remainder operator. Returns an integer if both operands are integers or a float if either or both are floats.
    **      | Power operator. Both operands are converted to floats and the result is a float.

You can overload the mathematical operators to customize their behaviour for your own types.



### Equality & Comparison Operators

The equality (`==`, `!=`) and comparison (`>`, `>=`, `<`, `<=`) operators each take two operands and evaluate to a boolean.

* Numbers are equal if their values are numerically equal.
* Strings are equal if they have the same content.
* Tuples are equal if they have the same length and their elements are equal.
* By default, other objects are equal only if they are the same object.



### Logical Operators

The logical operators are `||` (OR), `&&` (AND), and `!` (NOT). They evaluate the *truthiness* of their operands.

(In Pyro, the values `false`, `null`, and `err` are *falsey*; all other values are *truthy*.)

The logical operators `||` and `&&` are short-circuiting.

The value of the logical-OR expression `a || b` is the value of the first operand if that operand is *truthy*, otherwise the value of the second operand.

This means you can use the `||` operator to swap in a default value in place of a *falsey* expression:

::: code pyro
    var value = maybe_falsey() || "default";

The value of the logical-AND expression `a && b` is the value of the first operand if that operand is *falsey*, otherwise the value of the second operand.

This means you can use the `&&` operator to conditionally chain a sequence of expressions:

::: code pyro
    func1() && func2() && func3();

`func2()` will only be called if `func1()` returns a *truthy* value; `func3()` will only be called if `func2()` returns a *truthy* value.



### The Conditional Operator

The conditional or ternary operator takes three operands. It looks like this:

::: code pyro
    var value = condition ? expr1 :| expr2;

The value of the expression is `expr1` if `condition` evaluates as *truthy*, otherwise `expr2`.



### The Null-coalescing Operator

The null-coalescing operator `??` lets you swap in a default value in place of a `null`:

::: code pyro
    var value = maybe_null() ?? "default";

The value of the expression `a ?? b` is the value of the first operand if that operand is not `null`, otherwise the value of the second operand.

You can chain multiple `??` expressions, e.g.

::: code pyro
    var value = maybe_null() ?? get_fallback() ?? "default";



### The Error-coalescing Operator

The error-coalescing operator `!!` lets you swap in a default value in place of an error:

::: code pyro
    var value = maybe_error() !! "default";

The value of the expression `a !! b` is the value of the first operand if that operand is not an `err`, otherwise the value of the second operand.

You can chain multiple `!!` expressions, e.g.

::: code pyro
    var value = maybe_error() ?? get_fallback() ?? "default";



### The Else-coalescing Operator

The value of an `else` expression is the value of its first operand if that value is not one of (`false`, `null`, `err`, `0`, `0.0`, or `""`), otherwise the value of its second operand.

::: code pyro
    var value = get_value() else "default";

You can chain multiple `else` expressions, e.g.

::: code pyro
    var value = get_value() else get_fallback() else "default";





### Assignment Operators

An assignment expression returns the value assigned, e.g.

::: code pyro
    var foo;
    var bar = (foo = 5);
    assert bar == 5;

Assignment using a compound assignment operator, e.g.

::: code pyro
    foo += bar;

is equivalent to the longform expression:

::: code pyro
    foo = foo + bar;

Compound assignment operators cannot be overloaded independently of their base operators --- i.e. overloading `+` automatically overloads `+=`;



### Overloading Operators

The following operators can be overloaded by user-defined types:

* `()`
* `[]`
* `&`
* `^`
* `|`
* `==`
* `>`
* `>=`
* `<`
* `<=`
* `-` (binary/unary)
* `+` (binary/unary)
* `%`
* `/`
* `//`
* `*`
* `**`

You can overload these operators using the `$`-prefixed methods listed [here](@root/features/classes//#dollar-methods).
