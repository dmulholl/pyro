---
title: String Formatting
meta_title: Pyro &mdash; String Formatting
---

Use the `$fmt()` function to interpolate values into a string:

[[ `$fmt(format_string, arg1, arg2, ...)` ]]

    Returns the new string created by interpolating the argument values into the format string.

A format string is a string containing `{}` placeholders:


::: code pyro
    var foo = $fmt("{} and {}", 123, 456);
    assert foo == "123 and 456";

    var bar == $fmt("{} and {}", "foo", "bar");
    assert bar == "foo and bar";

An empty placeholder `{}` is equivalent to calling `$str(arg)` on the value and interpolating the resulting string.

A placeholder can contain a format specifier --- if the value has a `:$fmt(spec)` method defined, this method will be called and the resulting string will be used.

(The format specifier itself is an arbitrary string --- it's simply the content of the placeholder. How it's interpreted is up the value's `:$fmt(spec)` method.)



### Formatting Integers

You can use `printf`--style formatting specifiers to format `i64` values, e.g.

::: code pyro
    assert $fmt("{d}", 123) == "123";
    assert $fmt("{4d}", 123) == " 123";
    assert $fmt("{04d}", 123) == "0123";
    assert $fmt("{04x}", 123) == "007b";

The set of valid letters is:

* `d` for decimal.
* `o` for octal.
* `x` for lowercase hexadecimal.
* `X` for uppercase hexadecimal.

(Note that applying octal or hexadecimal formatting to a negative integer value returns its two's complement.)



### Formatting Floats

You can use `printf`--style formatting specifiers to format `f64` values, e.g.

::: code pyro
    assert $fmt("{.2f}", 1.23456) == "1.23";
    assert $fmt("{5.2f}", 1.23456) == " 1.23";
    assert $fmt("{05.2f}", 1.23456) == "01.23";

The set of valid letters is:

* `a` --- hexadecimal floating point, lowercase.
* `A` --- hexadecimal floating point, uppercase.
* `e` --- scientific notation, lowercase.
* `E` --- scientific notation, uppercase.
* `f` --- decimal floating point, lowercase.
* `F` --- decimal floating point, uppercase.
* `g` --- uses the shortest representation, `e` or `f`.
* `g` --- uses the shortest representation, `E` or `F`.



### Formatting Characters

You can use `printf`--style formatting specifiers to format `char` values as unsigned 32-bit integers, e.g.

::: code pyro
    assert $fmt("{d}", 'a') == "97";
    assert $fmt("{4d}", 'a') == "  97";
    assert $fmt("{x}", 'z') == "7a";
    assert $fmt("{04x}", 'z') == "007a";

The set of valid letters is:

* `d` for decimal.
* `o` for octal.
* `x` for lowercase hexadecimal.
* `X` for uppercase hexadecimal.



### Custom Class Example

Here's a sample class with custom `:$str()` and `:$fmt(spec)` methods:

::: code pyro
    class Foo {
        def $str() {
            return "<foo>";
        }

        def $fmt(spec) {
            return "<" + spec + ">";
        }
    }

Calling `$str(arg)` on an instance returns the output of its `:$str()` method:

::: code pyro
    var foo = Foo();
    assert $str(foo) == "<foo>";

An empty placeholder in a format string is equvialent to calling `$str(arg)` on the value:

::: code pyro
    assert $fmt("{}", foo) == "<foo>";

If the placeholder contains a format specifier, it gets passed to the value's `:$fmt(spec)` method:

::: code pyro
    assert $fmt("{xyz}", foo) == "<xyz>";
