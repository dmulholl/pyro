---
title: Type Annotations
meta_title: Pyro &mdash; Type Annotations
---

Pyro supports optional type annotations for variable, function, and method declarations, e.g.

::: code pyro
    var foo: i64 = 123;
    var bar: f64 = 1.0;

    def is_empty(content: str) -> bool {
        return content.byte_count() == 0;
    }

Pyro doesn't (currently) do anything with these type annotations, apart from verifying their syntax.
The language is dynamically typed and is intended to remain so, but you can use type annotations to document your code's intended interface.[^1]

::: footnote 1
    Future versions of Pyro may offer optional type checking or automatic documentation generation using declared variable types.
    Currently, the compiler simply verifies that type declarations are syntactically correct, then discards them.



### Builtin Types

Annotations for builtin types are as follows:

* `any`
* `bool`
* `buf`
* `char`
* `err`
* `err[type1, type2, ...]`
* `f64`
* `file`
* `i64`
* `map`
* `map[key_type, value_type]`
* `null`
* `range`
* `str`
* `tup`
* `tup[type1, type2, ...]`
* `vec`
* `vec[type]`

Type annotations beginning with a lowercase letter are reserved for language builtins.



### Syntax

Specify a variable's type by following its name with a colon and a type declaration:

::: code pyro
    var name: type;
    var name: type = value;

The same syntax works for function and method parameters:

::: code pyro
    def func(arg1: type, arg2: type) {
        ...
    }

Functions and methods can declare their return type by following their parameter list with an arrow, `->`, and a type declaration:

::: code pyro
    def func() -> type {
        ...
    }

Container types can optionally specify their content types in square brackets, e.g.

::: code pyro
    var foo: vec[str];
    var bar: map[str, i64];
    var baz: tup[i64, bool, str];

Where a type can be one of a discrete set of options, separate the options with a `|`, e.g.

::: code pyro
    var foo: i64|f64;
    var bar: map[str, i64|f64];

Type declarations can be nested as required, e.g.

::: code pyro
    var foo: vec[map[str, i64|f64]];

You can indicate that a type is nullable --- i.e. can be either the specified type or `null` --- by appending a `?`, e.g.

::: code pyro
    var foo: i64?;
    var bar: vec[str?];
    var baz: map[str, i64]?;

A type name should specify either one of the builtin types or a user-defined type, possibly imported from a module, e.g.

::: code pyro
    var foo: UserType;
    var bar: mod::UserType;



### Notes

::: insert footnotes
